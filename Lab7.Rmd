---
title: "RNA-seq workflow: gene-level exploratory analysis and differential expression"
output: html_document
theme: readable
---

```{r, echo=FALSE, message=FALSE}
library(airway)
library(tidyverse)
library(tximeta)
library(magrittr)
library(DESeq2)
library(vsn)
library(dplyr)
library(ggplot2)
library(pheatmap)
library(RColorBrewer)
library(PoiClaClu)
library(glmpca)
library(ggbeeswarm)
library(apeglm)
library(genefilter)
library(IHW) #from bioconductor
library(AnnotationDbi)
library(org.Hs.eg.db)
library(ReportingTools)
library(Gviz)
library(sva)
library(RUVSeq)
library(fission)
```

# Using Salmon and tximeta

Salmon maps (millions) sequence fragments to genes
```{r}
# Getting the full path to the directory where airway package stored data analyzed via Salmon

dir <- system.file("extdata", package="airway", mustWork=TRUE)

list.files(dir)
list.files(file.path(dir, "quants"))

#Read the csv.file
csvfile <- (file= file.path(dir, "sample_table.csv"))

coldata <- read_csv(csvfile)

#Using two samples from salmon quantitation
coldata <- coldata[1:2,]
coldata$names <- coldata$Run
coldata$files <- file.path(dir, "quants", coldata$names, "quant.sf.gz")
file.exists(coldata$files)


#Using taximeta library to to import quantifications

se <- tximeta(coldata)
dim(se)
head(rownames(se))


#Summarizing the transcript level quantitation to the gene level 

gse <- summarizeToGene(se)
dim(gse)
head(rownames(gse))

data(gse)
gse

assayNames(gse)

```

## SummarizedExperiment

```{r}



# Retrieving the matrix of counts in  SummarizedExperiments objects called gse
head(assay(gse),3)
colSums(assay(gse))


# Retrieving the information about genomic ranges in  SummarizedExperiments objects called gse
rowRanges(gse)

# Retrieving metadata about sequences in RowRanges above 
seqinfo(rowRanges(gse))


# Retrieving the dataframe/ sample information given to tximeta function for importing the quantitation data


colData(gse)

# Examine the columns of colData of gse
gse$donor
gse$condition

# Renaming the conditions
gse$cell <- gse$donor
gse$dex <- gse$condition
levels(gse$dex)
levels(gse$dex) <- c("untrt", "trt")
levels(gse$dex)
```




# Design formula

To find the differential expression of treatmentrs; untreated & dexamethasone, we use the formula ~condition. ‘condition’ is a column in colData.

To find the differential expression of treatment in different cell lines we use ~cell+dex


relevel() in library(magrittr)-
The levels of a factor are re-ordered so that the level specified by ref is first and the others are moved down. 

```{r}
#library(magrittr)
gse$dex %<>% relevel(ref = "untrt") 

# The above line is same as
gse$dex <- relevel(gse$dex, ref="untrt")


```


Find number of fragments mapped to genes by Salmon

```{r}
round(colSums(assay(gse))/10e6, 1)

```

Constructing a DESeqDataSet object from annotated SummarizedExperiment object

DESeqDataSet()-
The DESeqDataSet class enforces non-negative integer values in the "counts" matrix stored as the first element in the assay list. In addition, a formula which specifies the design of the experiment must be provided. 

```{r}
# library(DESeq2)
dds <- DESeqDataSet(gse, design = ~cell+dex)

```

Building an DESeqDataset (**if we do not have a SummarizedExperiment object **. In practise count matrix is read from a file or generated by  featureCounts from Rsubread)

1. Generae a a table with fragment counts
```{r}
countdata <- countdata<-round(gse@assays@data@listData[["counts"]])

head(countdata,3)
```

2. Generate a table with information about samples

```{r}
coldata <- colData(gse)
```


3. Generating the DESeqDataSet

```{r}
DESeqDataSetFromMatrix(countData = countdata,
                       colData = coldata,
                       design = ~cell+dex)
```

## Pre-filtering data set

Filter the rows with counts greater than zeros, or one accross all samples

counts()-
The counts slot holds the count data as a matrix of non-negative integer count values, one row for each observational unit (gene or the like), and one column for each sample.

```{r}
nrow(dds)
keep <- rowSums(counts(object = dds))>1
dds <-dds[keep,]
nrow(dds)
```

Filter the rows with at least 3 samples have a count of 10 or higher

```{r}
keep <- rowSums(counts(object=dds)>=10)>=3

dds <- dds[keep,]
nrow(dds)
```



## The variance stabilizing transformation and the rlog

For RNA-seq counts variance grows with mean. 
(Such data principal component analysis (PCA) of such data depends on highest counts as they show highest differences between samples.)

```{r, fig.align='center'}
lambda <- 10^seq(from=-1, to=2, length=1000)
cts<- matrix(rpois(1000*100, lambda), ncol=100)
#library(vsn)
meanSdPlot(cts, rank=FALSE)



```
To avoid the analysis depending on the samples with highest count in PCA analysis  log of normalized counts +1 is used

```{r, fig.align='center'}
log.cts.one <- log2(cts+1)
meanSdPlot(log.cts.one, ranks=FALSE)


```
 But this method amplifies the differences when the values are closer to 0.
 
**Resolution**

Stabilizing the variance across mean  using variance stabilizing transformation (VST) for genes with higher counts or regularized-logarithm transformation (rlog) for genes with lower counts

```{r}
vsd <- vst(dds, blind=FALSE)
head(assay(vsd),3)
colData(vsd)


rld <- rlog(dds, blind=FALSE)
head(assay(rld),3)
```
blind = FALSE  means that differences between
cell lines and treatment (the variables in the design) will not contribute to the expected variance mean
trend of the experiment.

fully unsupervised
transformation, one can set blind = TRUE


Showing the effect of transformation

```{r, fig.align='center'}

#library("dplyr")
#library("ggplot2")
dds <- estimateSizeFactors(dds)
df <- bind_rows(
as_data_frame(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
mutate(transformation = "log2(x + 1)"),
as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
colnames(df)[1:2] <- c("x", "y")
lvls <- c("log2(x + 1)", "vst", "rlog")
df$transformation <- factor(df$transformation, levels=lvls)
ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
coord_fixed() + facet_grid( . ~ transformation)
```

## Sample Distances

dist()- calculates the Euclidean distance between samples (in rows)


```{r}
sampleDists <-  dist(t(assay(vsd)))

sampleDists

```
Visualizing the distances using heat maps

1. 
```{r, fig.align='center'}
#library(pheatmap)
#library(RColorBrewer)
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( vsd$dex, vsd$cell, sep = " - " )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDists,
clustering_distance_cols = sampleDists,
col = colors)

```


2. Calculating the distances using  Poisson Distance

This method gets variance of counts into consideration when calculating the distance between samples

```{r, fig.align='center'}
#library(PoiClaClu)
poisd <- PoissonDistance(t(counts(dds)))

samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$dex, dds$cell, sep=" - " )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
clustering_distance_rows = poisd$dd,
clustering_distance_cols = poisd$dd,
col = colors)
```

3. a) PCA plot

```{r, fig.align='center'}
plotPCA(vsd, intgroup = c("dex", "cell"))
```

  b) PCA plot using ggplot

```{r, fig.align='center'}
pcaData <- plotPCA(vsd, intgroup = c( "dex", "cell"), returnData = TRUE)
pcaData

percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(x = PC1, y = PC2, color = dex, shape = cell)) +
geom_point(size =3) +
xlab(paste0("PC1: ", percentVar[1], "% variance")) +
ylab(paste0("PC2: ", percentVar[2], "% variance")) +
coord_fixed() +
ggtitle("PCA with VST data")
```
  c) PCA plot using Generalized PCA


```{r, fig.align='center'}
#library("glmpca")
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors
gpca.dat$dex <- dds$dex
gpca.dat$cell <- dds$cell

ggplot(gpca.dat, aes(x = dim1, y = dim2, color = dex, shape = cell)) +
geom_point(size =3) + coord_fixed() + ggtitle("glmpca - Generalized PCA")
```
4. a) Multidimensional scaling (MDS) plots.

This is done when no matrix data is available but matrix of distance is available.

```{r, fig.align='center'}
mds <- as.data.frame(colData(vsd)) %>%
cbind(cmdscale(sampleDistMatrix))
ggplot(mds, aes(x = `1`, y = `2`, color = dex, shape = cell)) +
geom_point(size = 3) + coord_fixed() + ggtitle("MDS with VST data")
```
  b) MDS plotting with VST data
  
```{r, fig.align='center'}
mdsPois <- as.data.frame(colData(dds)) %>%
cbind(cmdscale(samplePoisDistMatrix))
ggplot(mdsPois, aes(x = `1`, y = `2`, color = dex, shape = cell)) +
geom_point(size = 3) + coord_fixed() + ggtitle("MDS with PoissonDistances")
```
  
# Differential Expression Analysis

```{r}
dds <-DESeq(dds)
res <- results(dds)
res <- results(dds, contrast=c("dex","trt","untrt"))
mcols(res, use.names = TRUE)
summary(res)
res.05 <- results(dds, alpha = 0.05)
table(res.05$padj < 0.05)
resLFC1 <- results(dds, lfcThreshold=1)
table(resLFC1$padj < 0.1)
```
## Other Comparisons

```{r}
results(dds, contrast = c("cell", "N061011", "N61311"))
```
## Multiple testing

```{r}
sum(res$pvalue < 0.05, na.rm=TRUE)
sum(!is.na(res$pvalue))
sum(res$padj < 0.1, na.rm=TRUE)
resSig <- subset(res, padj < 0.1)
head(resSig[ order(resSig$log2FoldChange), ])

head(resSig[ order(resSig$log2FoldChange, decreasing = TRUE), ])
```
## Plotting Results

1. Counts plot

  a) Plotting using plotCounts
```{r, fig.align='center'}
topGene <- rownames(res)[which.min(res$padj)]
plotCounts(dds, gene = topGene, intgroup=c("dex"))
```
  b) Plotting using ggplot
  
```{r, fig.align='center'}
#library("ggbeeswarm")
geneCounts <- plotCounts(dds, gene = topGene, intgroup = c("dex","cell"),
returnData = TRUE)
ggplot(geneCounts, aes(x = dex, y = count, color = cell)) +
scale_y_log10() + geom_beeswarm(cex = 3)

ggplot(geneCounts, aes(x = dex, y = count, color = cell, group = cell)) +
scale_y_log10() + geom_point(size = 3) + geom_line()
```
2. MA-plot

MA-plot provides a useful overview for the distribution of the estimated
coefficients in the model, e.g. the comparisons of interest, across all genes.


```{r}
#library("apeglm")
resultsNames(dds)
res <- lfcShrink(dds, coef="dex_trt_vs_untrt", type="apeglm")
plotMA(res, ylim = c(-5, 5))
```
The above plot without removing the noisy log2 fold change 

```{r}
res.noshr <- results(dds, name="dex_trt_vs_untrt")
plotMA(res.noshr, ylim = c(-5, 5))
```
Labeling individual points

```{r}
plotMA(res, ylim = c(-5,5))
topGene <- rownames(res)[which.min(res$padj)]
with(res[topGene, ], {
points(baseMean, log2FoldChange, col="dodgerblue", cex=2, lwd=2)
text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})
```
3. Histogram

```{r}
hist(res$pvalue[res$baseMean > 1], breaks = 0:20/20,
col = "grey50", border = "white")
```
# Gene Clustering

eg. Plotting 20 genes with the highest variance across samples

```{r}
#library("genefilter")
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 20)

mat <- assay(vsd)[ topVarGenes, ]
mat <- mat - rowMeans(mat)
anno <- as.data.frame(colData(vsd)[, c("cell","dex")])
pheatmap(mat, annotation_col = anno)
```
# Independant filtering

```{r}
qs <- c(0, quantile(resLFC1$baseMean[resLFC1$baseMean > 0], 0:6/6))
bins <- cut(resLFC1$baseMean, qs)
levels(bins) <- paste0("~", round(signif((qs[-1] + qs[-length(qs)])/2, 2)))
fractionSig <- tapply(resLFC1$pvalue, bins, function(p)
mean(p < .05, na.rm = TRUE))
barplot(fractionSig, xlab = "mean normalized count",
ylab = "fraction of small p values")
```
# Independant hypothesis weighing

The idea of p value filtering is to weight hypotheses to optimize power. It can be done as shown below.
```{r}
#library("IHW")
res.ihw <- results(dds, filterFun=ihw)
```


# Annotating and exporting results

library(org.Hs.eg.db) is the organism annotation package (“org”) for Homo sapiens (“Hs”), organized as an
AnnotationDbi database package (“db”), using Entrez Gene IDs (“eg”) as primary key
```{r}
#library(AnnotationDbi)
#library(org.Hs.eg.db)
columns(org.Hs.eg.db)
```

mapIds()- add individual columns to result table

a) Add genesymbol
```{r}
ens.str <- substr(rownames(res), 1, 15)
res$symbol <- mapIds(org.Hs.eg.db,
keys=ens.str,
column="SYMBOL",
keytype="ENSEMBL",
multiVals="first")
res$entrez <- mapIds(org.Hs.eg.db,
keys=ens.str,
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
```
b) add entrez id

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
keys=ens.str,
column="ENTREZID",
keytype="ENSEMBL",
multiVals="first")
```
The results
```{r}
resOrdered <- res[order(res$pvalue),]
head(resOrdered)
```
# Exporting Results1) 
1) Saving as data frames
```{r}
resOrderedDF <- as.data.frame(resOrdered)[1:100, ]
write.csv(resOrderedDF, file = "Results/RNASEQ_results.csv")
```

2) Saving as dynamic html with external data base links, gene identifies and box plots withnormalized counts

```{r, eval=FALSE}
#library(ReportingTools)
htmlRep <- HTMLReport(shorthname= "report", title = "My report", )

htmlRep <- HTMLReport(shortName="report", title="My report",
reportDirectory="./report")
publish(resOrderedDF, htmlRep)
url <- finish(htmlRep)
browseURL(url)
```

# Plotting fold changes in genomic space

```{r}
resGR <- lfcShrink(dds=dds, coef="dex_trt_vs_untrt", type="apeglm", format="GRanges")
resGR

ens.str <- substr(names(resGR), 1, 15)
resGR$symbol <- mapIds(org.Hs.eg.db, ens.str, "SYMBOL", "ENSEMBL")

```


```{r}
#library(Gviz)


window <- resGR[topGene] + 1e6
strand(window) <- "*"
resGRsub <- resGR[resGR %over% window]
naOrDup <- is.na(resGRsub$symbol) | duplicated(resGRsub$symbol)
resGRsub$group <- ifelse(naOrDup, names(resGRsub), resGRsub$symbol)
```


#

Specifying a window of 1 million base pairs upstream and downstream
from the gene with the smallest p value.


```{r}
#library("Gviz")
window <- resGR[topGene] + 1e6
strand(window) <- "*"
resGRsub <- resGR[resGR %over% window]
naOrDup <- is.na(resGRsub$symbol) | duplicated(resGRsub$symbol)
resGRsub$group <- ifelse(naOrDup, names(resGRsub), resGRsub$symbol)

status <- factor(ifelse(resGRsub$padj < 0.05 & !is.na(resGRsub$padj),
"sig", "notsig"))

options(ucscChromosomeNames = FALSE)
g <- GenomeAxisTrack()
a <- AnnotationTrack(resGRsub, name = "gene ranges", feature = status)
d <- DataTrack(resGRsub, data = "log2FoldChange", baseline = 0,
type = "h", name = "log2 fold change", strand = "+")
plotTracks(list(g, d, a), groupAnnotation = "group",
notsig = "grey", sig = "hotpink")
```


# Using SVA with DESeq2

Recovering an batch effects by obtaining a matrix of normalized counts for which the average count across the samples is larger than 1

```{r}
dat <- counts(dds, normalized = TRUE)
idx <- rowMeans(dat) > 1
dat <- dat[idx, ]
mod <- model.matrix(~ dex, colData(dds))
mod0 <- model.matrix(~ 1, colData(dds))
svseq <- svaseq(dat, mod, mod0, n.sv = 2)

svseq$sv

par(mfrow = c(2, 1), mar = c(3,5,3,1))
for (i in 1:2) {
stripchart(svseq$sv[, i] ~ dds$cell, vertical = TRUE, main = paste0("SV", i))
abline(h = 0)
}

ddssva <- dds
ddssva$SV1 <- svseq$sv[,1]
ddssva$SV2 <- svseq$sv[,2]
design(ddssva) <- ~ SV1 + SV2 + dex
```


# Usng RUV with DESeq2

Detecting hidden batch effects
RUVg()- Estimates factors of unwanted variation

```{r}
#library(RUVSeq)
set <- newSeqExpressionSet(counts(dds))
idx <- rowSums(counts(set) > 5) >= 2
set <- set[idx, ]
set <- betweenLaneNormalization(set, which="upper")
not.sig <- rownames(res)[which(res$pvalue > .1)]
empirical <- rownames(set)[ rownames(set) %in% not.sig ]
set <- RUVg(set, empirical, k=2)
pData(set)

par(mfrow = c(2, 1), mar = c(3,5,3,1))
for (i in 1:2) {
stripchart(pData(set)[, i] ~ dds$cell, vertical = TRUE, main = paste0("W",
i))
abline(h = 0)
}
```
Above unwanted variation plotted over cell line is added to DESeqData Set and design

```{r}
ddsruv <- dds
ddsruv$W1 <- set$W_1
ddsruv$W2 <- set$W_2
design(ddsruv) <- ~ W1 + W2 + dex
```


# Time course experiments

```{r}
# library(fission)
data (fission)
ddsTC <- DESeqDataSet(fission, ~ strain + minute + strain:minute)
```

Remove the strain specific differences over time in fission data set
```{r}
ddsTC <- DESeq(ddsTC, test="LRT", reduced = ~ strain + minute)
resTC <- results(ddsTC)
resTC$symbol <- mcols(ddsTC)$symbol
head(resTC[order(resTC$padj),], 4)



```
Model the counts as a smooth function over time and to include an interaction term of the condition with smooth function

```{r}
fiss <- plotCounts(ddsTC, which.min(resTC$padj),
intgroup = c("minute","strain"), returnData = TRUE)
fiss$minute <- as.numeric(as.character(fiss$minute))
ggplot(fiss,
aes(x = minute, y = count, color = strain, group = strain)) +
geom_point() + stat_summary(fun.y=mean, geom="line") +
scale_y_log10()+
  labs(title="Normalized counts for a gene with condition-specific changes over time.")
```
Wald test for the log2 fold changes at individual time points can be investigated sing the test argument to results

```{r}
resultsNames(ddsTC)
res30 <- results(ddsTC, name="strainmut.minute30", test="Wald")
res30[which.min(resTC$padj),]
```

Clustering significant genes by their profiles

```{r}
betas <- coef(ddsTC)
colnames(betas)

topGenes <- head(order(resTC$padj),20)
mat <- betas[topGenes, -c(1,2)]
thr <- 3
mat[mat < -thr] <- -thr
mat[mat > thr] <- thr
pheatmap(mat, breaks=seq(from=-thr, to=thr, length=101),
cluster_col=FALSE)
```
Obtaining the version numbers of R and all the packages used in this session
```{r}
sessionInfo()
```

